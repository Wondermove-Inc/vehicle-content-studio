class e{constructor(){this.maxListeners=20,this.warnOnce=!1,this.events={}}on(e,t,s={}){let r=this.events[e];if(r||(r={highPriority:new Map,regular:new Map},this.events[e]=r),s.isFirst?r.highPriority.set(t,!0):r.regular.set(t,!0),"production"!==process.env.NODE_ENV){const t=r.highPriority.size+r.regular.size;t>this.maxListeners&&!this.warnOnce&&(this.warnOnce=!0,console.warn([`Possible EventEmitter memory leak detected. ${t} ${e} listeners added.`].join("\n")))}}removeListener(e,t){this.events[e]&&(this.events[e].regular.delete(t),this.events[e].highPriority.delete(t))}removeAllListeners(){this.events={}}emit(e,...t){const s=this.events[e];if(!s)return;const r=Array.from(s.highPriority.keys()),i=Array.from(s.regular.keys());for(let e=r.length-1;e>=0;e-=1){const i=r[e];s.highPriority.has(i)&&i.apply(this,t)}for(let e=0;e<i.length;e+=1){const r=i[e];s.regular.has(r)&&r.apply(this,t)}}once(e,t){const s=this;this.on(e,(function r(...i){s.removeListener(e,r),t.apply(s,i)}))}}export{e as EventManager};
