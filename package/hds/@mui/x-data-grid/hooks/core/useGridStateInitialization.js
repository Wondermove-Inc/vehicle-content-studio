import t from"../../../../@babel/runtime/helpers/esm/extends.js";import*as e from"react";import{isFunction as r}from"../../utils/utils.js";import{useGridApiMethod as a}from"../utils/useGridApiMethod.js";const n=n=>{const s=e.useRef({}),[,o]=e.useState(),u=e.useCallback((t=>{s.current[t.stateId]=t}),[]),c=e.useCallback(((t,e)=>{let a;if(a=r(t)?t(n.current.state):t,n.current.state===a)return!1;let o=!1;const u=[];if(Object.keys(s.current).forEach((t=>{const e=s.current[t],r=e.stateSelector(n.current.state,n.current.instanceId),c=e.stateSelector(a,n.current.instanceId);c!==r&&(u.push({stateId:e.stateId,hasPropChanged:c!==e.propModel}),void 0!==e.propModel&&c!==e.propModel&&(o=!0))})),u.length>1)throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${u[0].stateId}, therefore, you're not allowed to update ${u.map((t=>t.stateId)).join(", ")} in the same transaction.`);if(o||(n.current.state=a,n.current.publishEvent&&n.current.publishEvent("stateChange",a),n.current.store.update(a)),1===u.length){const{stateId:t,hasPropChanged:r}=u[0],c=s.current[t],l=c.stateSelector(a,n.current.instanceId);c.propOnChange&&r&&c.propOnChange(l,{reason:e,api:n.current}),o||n.current.publishEvent(c.changeEvent,l,{reason:e})}return!o}),[n]),l=e.useCallback(((e,r,a)=>n.current.setState((a=>t({},a,{[e]:r(a[e])})),a)),[n]),p=e.useCallback((()=>o((()=>n.current.state))),[n]),i={updateControlState:l,registerControlState:u};a(n,{setState:c,forceUpdate:p},"public"),a(n,i,"private")};export{n as useGridStateInitialization};
