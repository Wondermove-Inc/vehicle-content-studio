import r from"../../../../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js";import e from"../../../../../@babel/runtime/helpers/esm/toPropertyKey.js";import*as t from"react";import{useGridApiMethod as o}from"../../utils/useGridApiMethod.js";const s="none",n={rowTreeCreation:"rowTree",filtering:"rowTree",sorting:"rowTree",visibleRowsLookupCreation:"rowTree"},a=a=>{const i=t.useRef(new Map),c=t.useRef({}),u=t.useCallback(((t,o,s)=>{const i=()=>{const s=c.current[o],n=r(s,[t].map(e));c.current[o]=n};c.current[o]||(c.current[o]={});const u=c.current[o],l=u[t];return u[t]=s,l&&l!==s?(t===a.current.getActiveStrategy(n[o])&&a.current.publishEvent("activeStrategyProcessorChange",o),i):i}),[a]),l=t.useCallback(((r,e)=>{const t=a.current.getActiveStrategy(n[r]);if(null==t)throw new Error("Can't apply a strategy processor before defining an active strategy");const o=c.current[r];if(!o||!o[t])throw new Error(`No processor found for processor "${r}" on strategy "${t}"`);return(0,o[t])(e)}),[a]),p=t.useCallback((r=>{const e=Array.from(i.current.entries()).find((([,e])=>e.group===r&&e.isAvailable()));return e?.[0]??s}),[]),g=t.useCallback(((r,e,t)=>{i.current.set(e,{group:r,isAvailable:t}),a.current.publishEvent("strategyAvailabilityChange")}),[a]);o(a,{registerStrategyProcessor:u,applyStrategyProcessor:l,getActiveStrategy:p,setStrategyAvailability:g},"private")};export{s as GRID_DEFAULT_STRATEGY,n as GRID_STRATEGIES_PROCESSORS,a as useGridStrategyProcessing};
