import e from"../../../../../@babel/runtime/helpers/esm/toPropertyKey.js";import t from"../../../../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js";import r from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as o from"react";import{useGridApiEventHandler as s,useGridApiOptionHandler as i}from"../../utils/useGridApiEventHandler.js";import{GridRowModes as n,GridEditModes as l}from"../../../models/gridEditRowModel.js";import{useGridApiMethod as c}from"../../utils/useGridApiMethod.js";import{gridEditRowsStateSelector as d}from"./gridEditingSelectors.js";import{isPrintableKey as u,isPasteShortcut as a}from"../../../utils/keyboardUtils.js";import{gridVisibleColumnFieldsSelector as p,gridColumnFieldsSelector as w}from"../columns/gridColumnsSelector.js";import{buildWarning as f}from"../../../utils/warning.js";import{gridRowsDataRowIdToIdLookupSelector as m}from"../rows/gridRowsSelector.js";import{deepClone as E}from"../../../utils/utils.js";import{GridRowEditStartReasons as b,GridRowEditStopReasons as g}from"../../../models/params/gridRowParams.js";import{GRID_ACTIONS_COLUMN_TYPE as h}from"../../../colDef/gridActionsColDef.js";import P from"../../../../utils/useEventCallback/useEventCallback.js";import C from"../../../../utils/useEnhancedEffect/useEnhancedEffect.js";const R=["id"],M=["id"],v=f(["MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.","To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.","For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence."],"error"),k=(f,k)=>{const[y,j]=o.useState({}),V=o.useRef(y),D=o.useRef({}),S=o.useRef(),K=o.useRef(null),{processRowUpdate:F,onProcessRowUpdateError:U,rowModesModel:T,onRowModesModelChange:O}=k,A=e=>(...t)=>{k.editMode===l.Row&&e(...t)},x=o.useCallback(((e,t)=>{const r=f.current.getCellParams(e,t);if(!f.current.isCellEditable(r))throw new Error(`MUI X: The cell with id=${e} and field=${t} is not editable.`)}),[f]),I=o.useCallback(((e,t)=>{if(f.current.getRowMode(e)!==t)throw new Error(`MUI X: The row with id=${e} is not in ${t} mode.`)}),[f]),$=o.useCallback((e=>{const t=d(f.current.state);return Object.values(t[e]).some((e=>e.error))}),[f]),G=o.useCallback(((e,t)=>{if(!e.isEditable)return;if(f.current.getRowMode(e.id)===n.Edit)return;const o=f.current.getRowParams(e.id),s=r({},o,{field:e.field,reason:b.cellDoubleClick});f.current.publishEvent("rowEditStart",s,t)}),[f]),W=o.useCallback((e=>{K.current=e}),[]),X=o.useCallback(((e,t)=>{e.isEditable&&f.current.getRowMode(e.id)!==n.View&&(K.current=null,S.current=setTimeout((()=>{if(K.current?.id!==e.id){if(!f.current.getRow(e.id))return;if(f.current.getRowMode(e.id)===n.View)return;if($(e.id))return;const o=f.current.getRowParams(e.id),s=r({},o,{field:e.field,reason:g.rowFocusOut});f.current.publishEvent("rowEditStop",s,t)}})))}),[f,$]);o.useEffect((()=>()=>{clearTimeout(S.current)}),[]);const _=o.useCallback(((e,t)=>{if(e.cellMode===n.Edit){if(229===t.which)return;let o;if("Escape"===t.key)o=g.escapeKeyDown;else if("Enter"===t.key)o=g.enterKeyDown;else if("Tab"===t.key){const r=p(f).filter((t=>f.current.getColumn(t).type===h||f.current.isCellEditable(f.current.getCellParams(e.id,t))));if(t.shiftKey?e.field===r[0]&&(o=g.shiftTabKeyDown):e.field===r[r.length-1]&&(o=g.tabKeyDown),t.preventDefault(),!o){const o=r.findIndex((t=>t===e.field)),s=r[t.shiftKey?o-1:o+1];f.current.setCellFocus(e.id,s)}}if(o){if(o!==g.escapeKeyDown&&$(e.id))return;const s=r({},f.current.getRowParams(e.id),{reason:o,field:e.field});f.current.publishEvent("rowEditStop",s,t)}}else if(e.isEditable){let o;if(!f.current.unstable_applyPipeProcessors("canStartEditing",!0,{event:t,cellParams:e,editMode:"row"}))return;if(u(t)||a(t)?o=b.printableKeyDown:"Enter"===t.key?o=b.enterKeyDown:"Backspace"!==t.key&&"Delete"!==t.key||(o=b.deleteKeyDown),o){const s=f.current.getRowParams(e.id),i=r({},s,{field:e.field,reason:o});f.current.publishEvent("rowEditStart",i,t)}}}),[f,$]),N=o.useCallback((e=>{const{id:t,field:r,reason:o}=e,s={id:t,fieldToFocus:r};o!==b.printableKeyDown&&o!==b.deleteKeyDown||(s.deleteValue=!!r),f.current.startRowEditMode(s)}),[f]),B=o.useCallback((e=>{const{id:t,reason:r,field:o}=e;let s;f.current.runPendingEditCellValueMutation(t),r===g.enterKeyDown?s="below":r===g.tabKeyDown?s="right":r===g.shiftTabKeyDown&&(s="left");const i="escapeKeyDown"===r;f.current.stopRowEditMode({id:t,ignoreModifications:i,field:o,cellToFocusAfter:s})}),[f]);s(f,"cellDoubleClick",A(G)),s(f,"cellFocusIn",A(W)),s(f,"cellFocusOut",A(X)),s(f,"cellKeyDown",A(_)),s(f,"rowEditStart",A(N)),s(f,"rowEditStop",A(B)),i(f,"rowEditStart",k.onRowEditStart),i(f,"rowEditStop",k.onRowEditStop);const H=o.useCallback((e=>{if(k.editMode===l.Cell)return n.View;const t=d(f.current.state);return t[e]&&Object.keys(t[e]).length>0?n.Edit:n.View}),[f,k.editMode]),L=P((e=>{const t=e!==k.rowModesModel;O&&t&&O(e,{api:f.current}),k.rowModesModel&&t||(j(e),V.current=e,f.current.publishEvent("rowModesModelChange",e))})),q=o.useCallback(((e,t)=>{const o=r({},V.current);null!==t?o[e]=r({},t):delete o[e],L(o)}),[L]),z=o.useCallback(((e,t)=>{f.current.setState((o=>{const s=r({},o.editRows);return null!==t?s[e]=t:delete s[e],r({},o,{editRows:s})})),f.current.forceUpdate()}),[f]),J=o.useCallback(((e,t,o)=>{f.current.setState((s=>{const i=r({},s.editRows);return null!==o?i[e]=r({},i[e],{[t]:r({},o)}):(delete i[e][t],0===Object.keys(i[e]).length&&delete i[e]),r({},s,{editRows:i})})),f.current.forceUpdate()}),[f]),Q=o.useCallback((e=>{const{id:o}=e,s=t(e,R);I(o,n.View),q(o,r({mode:n.Edit},s))}),[I,q]),Y=P((e=>{const{id:t,fieldToFocus:r,deleteValue:o,initialValue:s}=e,i=w(f).reduce(((e,i)=>{if(!f.current.getCellParams(t,i).isEditable)return e;let n=f.current.getCellValue(t,i);return r===i&&(o||s)&&(n=o?"":s),e[i]={value:n,error:!1,isProcessingProps:!1},e}),{});z(t,i),r&&f.current.setCellFocus(t,r)})),Z=o.useCallback((e=>{const{id:o}=e,s=t(e,M);I(o,n.Edit),q(o,r({mode:n.View},s))}),[I,q]),ee=P((e=>{const{id:t,ignoreModifications:r,field:o,cellToFocusAfter:s="none"}=e;f.current.runPendingEditCellValueMutation(t);const i=()=>{"none"!==s&&o&&f.current.moveFocusToRelativeCell(t,o,s),z(t,null),q(t,null)};if(r)return void i();const l=d(f.current.state),c=f.current.getRow(t);if(Object.values(l[t]).some((e=>e.isProcessingProps)))return void(D.current[t].mode=n.Edit);if($(t))return D.current[t].mode=n.Edit,void q(t,{mode:n.Edit});const u=f.current.getRowWithUpdatedValuesFromRowEditing(t);if(F){const e=e=>{D.current[t].mode=n.Edit,q(t,{mode:n.Edit}),U?U(e):"production"!==process.env.NODE_ENV&&v()};try{Promise.resolve(F(u,c)).then((e=>{f.current.updateRows([e]),i()})).catch(e)}catch(t){e(t)}}else f.current.updateRows([u]),i()})),te={setRowEditingEditCellValue:o.useCallback((o=>{const{id:s,field:i,value:l,debounceMs:c,unstable_skipValueParser:u}=o;x(s,i);const a=f.current.getColumn(i),p=f.current.getRow(s);let w=l;a.valueParser&&!u&&(w=a.valueParser(l,p,a,f));let m=d(f.current.state),E=r({},m[s][i],{value:w,changeReason:c?"debouncedSetEditCellValue":"setEditCellValue"});return a.preProcessEditCellProps||J(s,i,E),new Promise((o=>{const l=[];if(a.preProcessEditCellProps){const c=E.value!==m[s][i].value;E=r({},E,{isProcessingProps:!0}),J(s,i,E);const u=m[s],b=t(u,[i].map(e)),g=Promise.resolve(a.preProcessEditCellProps({id:s,row:p,props:E,hasChanged:c,otherFieldsProps:b})).then((e=>{f.current.getRowMode(s)!==n.View?(m=d(f.current.state),(e=r({},e,{isProcessingProps:!1})).value=a.preProcessEditCellProps?m[s][i].value:w,J(s,i,e)):o(!1)}));l.push(g)}Object.entries(m[s]).forEach((([c,u])=>{if(c===i)return;const a=f.current.getColumn(c);if(!a.preProcessEditCellProps)return;u=r({},u,{isProcessingProps:!0}),J(s,c,u),m=d(f.current.state);const w=m[s],E=t(w,[c].map(e)),b=Promise.resolve(a.preProcessEditCellProps({id:s,row:p,props:u,hasChanged:!1,otherFieldsProps:E})).then((e=>{f.current.getRowMode(s)!==n.View?(e=r({},e,{isProcessingProps:!1}),J(s,c,e)):o(!1)}));l.push(b)})),Promise.all(l).then((()=>{f.current.getRowMode(s)===n.Edit?(m=d(f.current.state),o(!m[s][i].error)):o(!1)}))}))}),[f,x,J]),getRowWithUpdatedValuesFromRowEditing:o.useCallback((e=>{const t=d(f.current.state),o=f.current.getRow(e);if(!t[e])return f.current.getRow(e);let s=r({},o);return Object.entries(t[e]).forEach((([e,t])=>{const r=f.current.getColumn(e);r.valueSetter?s=r.valueSetter(t.value,s,r,f):s[e]=t.value})),s}),[f])};c(f,{getRowMode:H,startRowEditMode:Q,stopRowEditMode:Z},"public"),c(f,te,"private"),o.useEffect((()=>{T&&L(T)}),[T,L]),C((()=>{const e=m(f),t=D.current;D.current=E(y);const o=new Set([...Object.keys(y),...Object.keys(t)]);Array.from(o).forEach((o=>{const s=y[o]??{mode:n.View},i=t[o]?.mode||n.View,l=e[o]??o;s.mode===n.Edit&&i===n.View?Y(r({id:l},s)):s.mode===n.View&&i===n.Edit&&ee(r({id:l},s))}))}),[f,y,Y,ee])};export{k as useGridRowEditing};
