import e from"../../../../../@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js";import t from"../../../../../@babel/runtime/helpers/esm/toPropertyKey.js";import r from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as l from"react";import{useGridApiEventHandler as o,useGridApiOptionHandler as s}from"../../utils/useGridApiEventHandler.js";import{GridCellModes as i,GridEditModes as n}from"../../../models/gridEditRowModel.js";import{useGridApiMethod as c}from"../../utils/useGridApiMethod.js";import{gridEditRowsStateSelector as a}from"./gridEditingSelectors.js";import{isPrintableKey as d,isPasteShortcut as u}from"../../../utils/keyboardUtils.js";import{buildWarning as p}from"../../../utils/warning.js";import{gridRowsDataRowIdToIdLookupSelector as f}from"../rows/gridRowsSelector.js";import{deepClone as E}from"../../../utils/utils.js";import{GridCellEditStartReasons as m,GridCellEditStopReasons as w}from"../../../models/params/gridEditCellParams.js";import b from"../../../../utils/useEventCallback/useEventCallback.js";import C from"../../../../utils/useEnhancedEffect/useEnhancedEffect.js";const h=["id","field"],g=["id","field"],y=p(["MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.","To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.","For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence."],"error"),k=(p,k)=>{const[M,v]=l.useState({}),P=l.useRef(M),R=l.useRef({}),{processRowUpdate:D,onProcessRowUpdateError:V,cellModesModel:j,onCellModesModelChange:S}=k,K=e=>(...t)=>{k.editMode===n.Cell&&e(...t)},U=l.useCallback(((e,t)=>{const r=p.current.getCellParams(e,t);if(!p.current.isCellEditable(r))throw new Error(`MUI X: The cell with id=${e} and field=${t} is not editable.`)}),[p]),T=l.useCallback(((e,t,r)=>{if(p.current.getCellMode(e,t)!==r)throw new Error(`MUI X: The cell with id=${e} and field=${t} is not in ${r} mode.`)}),[p]),F=l.useCallback(((e,t)=>{if(!e.isEditable)return;if(e.cellMode===i.Edit)return;const l=r({},e,{reason:m.cellDoubleClick});p.current.publishEvent("cellEditStart",l,t)}),[p]),O=l.useCallback(((e,t)=>{if(e.cellMode===i.View)return;if(p.current.getCellMode(e.id,e.field)===i.View)return;const l=r({},e,{reason:w.cellFocusOut});p.current.publishEvent("cellEditStop",l,t)}),[p]),A=l.useCallback(((e,t)=>{if(e.cellMode===i.Edit){if(229===t.which)return;let l;if("Escape"===t.key?l=w.escapeKeyDown:"Enter"===t.key?l=w.enterKeyDown:"Tab"===t.key&&(l=t.shiftKey?w.shiftTabKeyDown:w.tabKeyDown,t.preventDefault()),l){const o=r({},e,{reason:l});p.current.publishEvent("cellEditStop",o,t)}}else if(e.isEditable){let l;if(!p.current.unstable_applyPipeProcessors("canStartEditing",!0,{event:t,cellParams:e,editMode:"cell"}))return;if(d(t)?l=m.printableKeyDown:u(t)?l=m.pasteKeyDown:"Enter"===t.key?l=m.enterKeyDown:"Backspace"!==t.key&&"Delete"!==t.key||(l=m.deleteKeyDown),l){const o=r({},e,{reason:l,key:t.key});p.current.publishEvent("cellEditStart",o,t)}}}),[p]),$=l.useCallback((e=>{const{id:t,field:r,reason:l}=e,o={id:t,field:r};l!==m.printableKeyDown&&l!==m.deleteKeyDown&&l!==m.pasteKeyDown||(o.deleteValue=!0),p.current.startCellEditMode(o)}),[p]),x=l.useCallback((e=>{const{id:t,field:r,reason:l}=e;let o;p.current.runPendingEditCellValueMutation(t,r),l===w.enterKeyDown?o="below":l===w.tabKeyDown?o="right":l===w.shiftTabKeyDown&&(o="left");const s="escapeKeyDown"===l;p.current.stopCellEditMode({id:t,field:r,ignoreModifications:s,cellToFocusAfter:o})}),[p]);var G;o(p,"cellDoubleClick",K(F)),o(p,"cellFocusOut",K(O)),o(p,"cellKeyDown",K(A)),o(p,"cellEditStart",K($)),o(p,"cellEditStop",K(x)),s(p,"cellEditStart",k.onCellEditStart),s(p,"cellEditStop",(G=k.onCellEditStop,async(...e)=>{if(G){const{id:t,field:r}=e[0],l=p.current.state.editRows,o=l[t][r]?.error;o||G(...e)}}));const I=l.useCallback(((e,t)=>{const r=a(p.current.state);return r[e]&&r[e][t]?i.Edit:i.View}),[p]),W=b((e=>{const t=e!==k.cellModesModel;S&&t&&S(e,{api:p.current}),k.cellModesModel&&t||(v(e),P.current=e,p.current.publishEvent("cellModesModelChange",e))})),X=l.useCallback(((l,o,s)=>{const i=r({},P.current);if(null!==s)i[l]=r({},i[l],{[o]:r({},s)});else{const r=i[l],s=e(r,[o].map(t));i[l]=s,0===Object.keys(i[l]).length&&delete i[l]}W(i)}),[W]),_=l.useCallback(((e,t,l)=>{p.current.setState((o=>{const s=r({},o.editRows);return null!==l?s[e]=r({},s[e],{[t]:r({},l)}):(delete s[e][t],0===Object.keys(s[e]).length&&delete s[e]),r({},o,{editRows:s})})),p.current.forceUpdate()}),[p]),N=l.useCallback((t=>{const{id:l,field:o}=t,s=e(t,h);U(l,o),T(l,o,i.View),X(l,o,r({mode:i.Edit},s))}),[U,T,X]),B=b((e=>{const{id:t,field:r,deleteValue:l,initialValue:o}=e;let s=p.current.getCellValue(t,r);if(l){switch(p.current.getColumn(r).type){case"boolean":s=!1;break;case"date":case"dateTime":case"number":s=void 0;break;case"singleSelect":s=null;break;default:s=""}}else o&&(s=o);_(t,r,{value:s,error:!1,isProcessingProps:!1}),p.current.setCellFocus(t,r)})),H=l.useCallback((t=>{const{id:l,field:o}=t,s=e(t,g);T(l,o,i.Edit),X(l,o,r({mode:i.View},s))}),[T,X]),L=b((async e=>{const{id:t,field:r,ignoreModifications:l,cellToFocusAfter:o="none"}=e;T(t,r,i.Edit),p.current.runPendingEditCellValueMutation(t,r);const s=()=>{_(t,r,null),X(t,r,null),"none"!==o&&p.current.moveFocusToRelativeCell(t,r,o)};if(l)return void s();const n=a(p.current.state),{error:c,isProcessingProps:d}=n[t][r];if(c||d)return R.current[t][r].mode=i.Edit,void X(t,r,{mode:i.Edit});const u=p.current.getRowWithUpdatedValuesFromCellEditing(t,r);if(D){const e=e=>{R.current[t][r].mode=i.Edit,X(t,r,{mode:i.Edit}),V?V(e):"production"!==process.env.NODE_ENV&&y()};try{const r=p.current.getRow(t);Promise.resolve(D(u,r)).then((e=>{p.current.updateRows([e]),s()})).catch(e)}catch(t){e(t)}}else p.current.updateRows([u]),s()})),q={setCellEditingEditCellValue:l.useCallback((async e=>{const{id:t,field:l,value:o,debounceMs:s,unstable_skipValueParser:n}=e;U(t,l),T(t,l,i.Edit);const c=p.current.getColumn(l),d=p.current.getRow(t);let u=o;c.valueParser&&!n&&(u=c.valueParser(o,d,c,p));let f=a(p.current.state),E=r({},f[t][l],{value:u,changeReason:s?"debouncedSetEditCellValue":"setEditCellValue"});if(c.preProcessEditCellProps){const e=o!==f[t][l].value;E=r({},E,{isProcessingProps:!0}),_(t,l,E),E=await Promise.resolve(c.preProcessEditCellProps({id:t,row:d,props:E,hasChanged:e}))}return p.current.getCellMode(t,l)!==i.View&&(f=a(p.current.state),E=r({},E,{isProcessingProps:!1}),E.value=c.preProcessEditCellProps?f[t][l].value:u,_(t,l,E),f=a(p.current.state),!f[t]?.[l]?.error)}),[p,U,T,_]),getRowWithUpdatedValuesFromCellEditing:l.useCallback(((e,t)=>{const l=p.current.getColumn(t),o=a(p.current.state),s=p.current.getRow(e);if(!o[e]||!o[e][t])return p.current.getRow(e);const{value:i}=o[e][t];return l.valueSetter?l.valueSetter(i,s,l,p):r({},s,{[t]:i})}),[p])};c(p,{getCellMode:I,startCellEditMode:N,stopCellEditMode:H},"public"),c(p,q,"private"),l.useEffect((()=>{j&&W(j)}),[j,W]),C((()=>{const e=f(p),t=R.current;R.current=E(M),Object.entries(M).forEach((([l,o])=>{Object.entries(o).forEach((([o,s])=>{const n=t[l]?.[o]?.mode||i.View,c=e[l]??l;s.mode===i.Edit&&n===i.View?B(r({id:c,field:o},s)):s.mode===i.View&&n===i.Edit&&L(r({id:c,field:o},s))}))}))}),[p,M,B,L])};export{k as useGridCellEditing};
