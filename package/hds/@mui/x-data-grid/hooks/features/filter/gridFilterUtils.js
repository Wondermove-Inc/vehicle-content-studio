import e from"../../../../../@babel/runtime/helpers/esm/extends.js";import{getDefaultGridFilterModel as r}from"./gridFilterState.js";import{buildWarning as t}from"../../../utils/warning.js";import{getPublicApiRef as n}from"../../../utils/getPublicApiRef.js";import{gridColumnLookupSelector as i,gridVisibleColumnFieldsSelector as l,gridColumnFieldsSelector as o}from"../columns/gridColumnsSelector.js";import{GridLogicOperator as u}from"../../../models/gridFilterItem.js";let s;const c=(r,t)=>{const n=e({},r);if(null==n.id&&(n.id=Math.round(1e5*Math.random())),null==n.operator){const e=i(t)[n.field];n.operator=e&&e.filterOperators[0].value}return n},f=t(["MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.","If you are using the community version of the `DataGrid`, this prop is always `true`."],"error"),a=t("MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.","error"),p=t("MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.","error"),m=(r,t,n)=>{const i=r.items.length>1;let l;i&&t?(f(),l=[r.items[0]]):l=r.items;const o=i&&l.some((e=>null==e.id)),u=l.some((e=>null==e.operator));return o&&a(),u&&p(),u||o?e({},r,{items:l.map((e=>c(e,n)))}):r.items!==l?e({},r,{items:l}):r},d=(r,t,n)=>i=>e({},i,{filterModel:m(r,t,n)}),g=e=>"string"==typeof e?e.normalize("NFD").replace(/[\u0300-\u036f]/g,""):e,h=(r,t)=>{if(!r.field||!r.operator)return null;const i=t.current.getColumn(r.field);if(!i)return null;let l;if(i.valueParser){const e=i.valueParser;l=Array.isArray(r.value)?r.value?.map((r=>e(r,void 0,i,t))):e(r.value,void 0,i,t)}else l=r.value;const{ignoreDiacritics:o}=t.current.rootProps;o&&(l=g(l));const u=e({},r,{value:l}),s=i.filterOperators;if(!s?.length)throw new Error(`MUI X: No filter operators found for column '${i.field}'.`);const c=s.find((e=>e.value===u.operator));if(!c)throw new Error(`MUI X: No filter operator found for column '${i.field}' and operator value '${u.operator}'.`);const f=n(t),a=c.getApplyFilterFn(u,i);return"function"!=typeof a?null:{item:u,fn:e=>{let r=t.current.getRowValue(e,i);return o&&(r=g(r)),a(r,e,i,f)}}};let F=1;const y=(e,r,t)=>{const{items:n}=e,i=n.map((e=>h(e,r))).filter((e=>!!e));if(0===i.length)return null;if(t||!function(){if(void 0!==s)return s;try{s=new Function("return true")()}catch(e){s=!1}return s}())return(e,r)=>{const t={};for(let n=0;n<i.length;n+=1){const l=i[n];r&&!r(l.item.field)||(t[l.item.id]=l.fn(e))}return t};const l=new Function("appliers","row","shouldApplyFilter",`"use strict";\n${i.map(((e,r)=>`const shouldApply${r} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(e.item.field)});`)).join("\n")}\n\nconst result$$ = {\n${i.map(((e,r)=>`  ${JSON.stringify(String(e.item.id))}: !shouldApply${r} ? false : appliers[${r}].fn(row),`)).join("\n")}\n};\n\nreturn result$$;`.replaceAll("$$",String(F)));F+=1;return(e,r)=>l(i,e,r)},v=e=>e.quickFilterExcludeHiddenColumns??!0,$=(e,r,t)=>{const i=y(e,r,t),u=((e,r)=>{const t=e.quickFilterValues?.filter(Boolean)??[];if(0===t.length)return null;const i=v(e)?l(r):o(r),u=[],{ignoreDiacritics:s}=r.current.rootProps,c=n(r);return i.forEach((e=>{const n=r.current.getColumn(e),i=n?.getApplyQuickFilterFn;i&&u.push({column:n,appliers:t.map((e=>{const r=s?g(e):e;return{fn:i(r,n,c)}}))})})),function(e,n){const i={};e:for(let l=0;l<t.length;l+=1){const o=t[l];for(let t=0;t<u.length;t+=1){const{column:f,appliers:a}=u[t],{field:p}=f;if(n&&!n(p))continue;const m=a[l];let d=r.current.getRowValue(e,f);if(null!==m.fn&&(s&&(d=g(d)),m.fn(d,e,f,c))){i[o]=!0;continue e}}i[o]=!1}return i}})(e,r);return function(e,r,t){t.passingFilterItems=i?.(e,r)??null,t.passingQuickFilterValues=u?.(e,r)??null}},w=e=>null!=e,A=(e,t,n,i,l)=>{const o=((e,r,t)=>(e.cleanedFilterItems||(e.cleanedFilterItems=t.filter((e=>null!==h(e,r)))),e.cleanedFilterItems))(l,i,n.items),s=e.filter(w),c=t.filter(w);if(s.length>0){const e=e=>s.some((r=>r[e.id]));if((n.logicOperator??r().logicOperator)===u.And){if(!o.every(e))return!1}else{if(!o.some(e))return!1}}if(c.length>0&&null!=n.quickFilterValues){const e=e=>c.some((r=>r[e]));if((n.quickFilterLogicOperator??r().quickFilterLogicOperator)===u.And){if(!n.quickFilterValues.every(e))return!1}else{if(!n.quickFilterValues.some(e))return!1}}return!0};export{$ as buildAggregatedFilterApplier,c as cleanFilterItem,d as mergeStateWithFilterModel,A as passFilterLogic,g as removeDiacritics,m as sanitizeFilterModel,v as shouldQuickFilterExcludeHiddenColumns};
