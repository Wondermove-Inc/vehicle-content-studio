import e from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as t from"react";import{useGridVisibleRows as r}from"../../utils/useGridVisibleRows.js";import{useGridApiMethod as s}from"../../utils/useGridApiMethod.js";import{useGridSelector as o}from"../../utils/useGridSelector.js";import{gridDensityFactorSelector as i}from"../density/densitySelector.js";import{gridFilterModelSelector as n}from"../filter/gridFilterSelector.js";import{gridPaginationSelector as u}from"../pagination/gridPaginationSelector.js";import{gridSortModelSelector as a}from"../sorting/gridSortingSelector.js";import{gridPinnedRowsSelector as c}from"./gridRowsSelector.js";import{DATA_GRID_PROPS_DEFAULT_VALUES as l}from"../../../DataGrid/useDataGridProps.js";import d from"../../../../utils/debounce/debounce.js";import{useGridRegisterPipeApplier as g}from"../../core/pipeProcessing/useGridRegisterPipeApplier.js";const p=t=>e({},t,{rowsMeta:{currentPageTotalHeight:0,positions:[]}});let b=!1;const m=(e,t,r)=>"number"==typeof e&&e>0?e:("production"===process.env.NODE_ENV||b||null==e||(console.warn(r),b=!0),t),h=["MUI X: The `rowHeight` prop should be a number greater than 0.","The default value will be used instead."].join("\n"),f=["MUI X: The `getRowHeight` prop should return a number greater than 0 or 'auto'.","The default value will be used instead."].join("\n"),w=(p,b)=>{const{getRowHeight:w,getRowSpacing:R,getEstimatedRowHeight:H}=b,C=t.useRef(Object.create(null)),M=t.useRef(-1),j=t.useRef(!1),z=o(p,i),P=o(p,n),F=o(p,u),S=o(p,a),T=r(p,b),k=o(p,c),y=m(b.rowHeight,l.rowHeight,h),_=Math.floor(y*z),v=t.useCallback((()=>{j.current=!1;const t=t=>{C.current[t.id]||(C.current[t.id]={sizes:{baseCenter:_},isResized:!1,autoHeight:!1,needsFirstMeasurement:!0});const{isResized:r,needsFirstMeasurement:s,sizes:o}=C.current[t.id];let i="number"==typeof _&&_>0?_:52;const n=o.baseCenter;if(r)i=n;else if(w){const r=w(e({},t,{densityFactor:z}));if("auto"===r){if(s){i=(H?H(e({},t,{densityFactor:z})):_)??_}else i=n;j.current=!0,C.current[t.id].autoHeight=!0}else i=m(r,_,f),C.current[t.id].needsFirstMeasurement=!1,C.current[t.id].autoHeight=!1}else C.current[t.id].needsFirstMeasurement=!1;const u={baseCenter:i};if(R){const r=p.current.getRowIndexRelativeToVisibleRows(t.id),s=R(e({},t,{isFirstVisible:0===r,isLastVisible:r===T.rows.length-1,indexRelativeToCurrentPage:r}));u.spacingTop=s.top??0,u.spacingBottom=s.bottom??0}const a=p.current.unstable_applyPipeProcessors("rowHeight",u,t);return C.current[t.id].sizes=a,a},r=[],s=T.rows.reduce(((e,s)=>{r.push(e);let o=0;const i=t(s);for(const e in i){const t=i[e];"baseCenter"!==e&&(o+=t)}return e+i.baseCenter+o}),0);k?.top?.forEach((e=>{t(e)})),k?.bottom?.forEach((e=>{t(e)})),p.current.setState((t=>e({},t,{rowsMeta:{currentPageTotalHeight:s,positions:r}}))),j.current||(M.current=1/0),p.current.forceUpdate()}),[p,T.rows,_,w,R,H,k,z]),x=t.useCallback((e=>{const t=C.current[e];return t?t.sizes.baseCenter:_}),[_]),E=t.useCallback(((e,t)=>{C.current[e].sizes.baseCenter=t,C.current[e].isResized=!0,C.current[e].needsFirstMeasurement=!1,v()}),[v]),G=t.useMemo((()=>d(v,b.rowPositionsDebounceMs)),[v,b.rowPositionsDebounceMs]),I=t.useCallback(((e,t)=>{if(!C.current[e]||!C.current[e].autoHeight)return;const r=C.current[e].sizes.baseCenter!==t;C.current[e].needsFirstMeasurement=!1,C.current[e].sizes.baseCenter=t,r&&G()}),[G]),D=t.useCallback((e=>C.current[e]?.autoHeight||!1),[]),V=t.useCallback((()=>M.current),[]),A=t.useCallback((e=>{j.current&&e>M.current&&(M.current=e)}),[]),L=t.useCallback((()=>{C.current={},v()}),[v]);t.useEffect((()=>{v()}),[_,P,F,S,v]),g(p,"rowHeight",v);const U={getLastMeasuredRowIndex:V,rowHasAutoHeight:D};s(p,{unstable_setLastMeasuredRowIndex:A,unstable_getRowHeight:x,unstable_getRowInternalSizes:e=>C.current[e]?.sizes,unstable_setRowHeight:E,unstable_storeRowHeightMeasurement:I,resetRowHeights:L},"public"),s(p,U,"private")};export{p as rowsMetaStateInitializer,w as useGridRowsMeta};
