import e from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as o from"react";import{useGridApiMethod as r}from"../../utils/useGridApiMethod.js";import{useGridLogger as t}from"../../utils/useGridLogger.js";import{gridRowsLookupSelector as n,gridDataRowIdsSelector as s,gridRowCountSelector as a,gridRowTreeSelector as u,gridRowMaximumTreeDepthSelector as i,gridRowsDataRowIdToIdLookupSelector as w,gridRowGroupingNameSelector as c,gridRowTreeDepthsSelector as d}from"./gridRowsSelector.js";import{GridSignature as l,useGridApiEventHandler as p}from"../../utils/useGridApiEventHandler.js";import{useGridVisibleRows as g}from"../../utils/useGridVisibleRows.js";import{gridSortedRowIdsSelector as h}from"../sorting/gridSortingSelector.js";import{gridFilteredRowsLookupSelector as R}from"../filter/gridFilterSelector.js";import{isAutoGeneratedRow as f,GRID_ID_AUTOGENERATED as C,createRowsInternalCache as I,getRowIdFromRowModel as b,updateCacheWithNewRows as m,getTreeNodeDescendants as k,GRID_ROOT_GROUP_ID as v,getTopLevelRowCount as P,getRowsStateFromCache as U}from"./gridRowsUtils.js";import E from"../../../../utils/useTimeout/useTimeout.js";import{useGridRegisterPipeApplier as T}from"../../core/pipeProcessing/useGridRegisterPipeApplier.js";const y=(o,r,t)=>(t.current.caches.rows=I({rows:r.rows,getRowId:r.getRowId,loading:r.loading,rowCount:r.rowCount}),e({},o,{rows:U({apiRef:t,rowCountProp:r.rowCount,loadingProp:r.loading,previousTree:null,previousTreeDepths:null})})),M=(y,M)=>{if("production"!==process.env.NODE_ENV)try{Object.freeze(M.rows)}catch(e){}const S=t(y,"useGridRows"),G=g(y,M),D=o.useRef(Date.now()),j=o.useRef(M.rowCount),x=E(),L=o.useCallback((e=>{const o=n(y)[e];if(o)return o;const r=y.current.getRowNode(e);return r&&f(r)?{[C]:e}:null}),[y]),A=M.getRowId,N=o.useCallback((e=>C in e?e[C]:A?A(e):e.id),[A]),B=o.useMemo((()=>G.rows.reduce(((e,{id:o},r)=>(e[o]=r,e)),{})),[G.rows]),X=o.useCallback((({cache:o,throttle:r})=>{const t=()=>{D.current=Date.now(),y.current.setState((o=>e({},o,{rows:U({apiRef:y,rowCountProp:M.rowCount,loadingProp:M.loading,previousTree:u(y),previousTreeDepths:d(y)})}))),y.current.publishEvent("rowsSet"),y.current.forceUpdate()};if(x.clear(),y.current.caches.rows=o,!r)return void t();const n=M.throttleRowsMs-(Date.now()-D.current);n>0?x.start(n,t):t()}),[M.throttleRowsMs,M.rowCount,M.loading,y,x]),$=o.useCallback((e=>{S.debug(`Updating all rows, new length ${e.length}`);const o=I({rows:e,getRowId:M.getRowId,loading:M.loading,rowCount:M.rowCount}),r=y.current.caches.rows;o.rowsBeforePartialUpdates=r.rowsBeforePartialUpdates,X({cache:o,throttle:!0})}),[S,M.getRowId,M.loading,M.rowCount,X,y]),_=o.useCallback((o=>{if(M.signature===l.DataGrid&&o.length>1)throw new Error(["MUI X: You cannot update several rows at once in `apiRef.current.updateRows` on the DataGrid.","You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));const r=[];o.forEach((o=>{const t=b(o,M.getRowId,"A row was provided without id when calling updateRows():"),n=y.current.getRowNode(t);if("pinnedRow"===n?.type){const r=y.current.caches.pinnedRows,n=r.idLookup[t];n&&(r.idLookup[t]=e({},n,o))}else r.push(o)}));const t=m({updates:r,getRowId:M.getRowId,previousCache:y.current.caches.rows});X({cache:t,throttle:!0})}),[M.signature,M.getRowId,X,y]),Y=o.useCallback((()=>{const e=s(y),o=n(y);return new Map(e.map((e=>[e,o[e]??{}])))}),[y]),O=o.useCallback((()=>a(y)),[y]),V=o.useCallback((()=>s(y)),[y]),F=o.useCallback((e=>B[e]),[B]),z=o.useCallback(((o,r)=>{const t=y.current.getRowNode(o);if(!t)throw new Error(`MUI X: No row with id #${o} found.`);if("group"!==t.type)throw new Error("MUI X: Only group nodes can be expanded or collapsed.");const n=e({},t,{childrenExpanded:r});y.current.setState((r=>e({},r,{rows:e({},r.rows,{tree:e({},r.rows.tree,{[o]:n})})}))),y.current.forceUpdate(),y.current.publishEvent("rowExpansionChange",n)}),[y]),H=o.useCallback((e=>u(y)[e]??null),[y]),K=o.useCallback((({skipAutoGeneratedRows:e=!0,groupId:o,applySorting:r,applyFiltering:t})=>{const n=u(y);let s;if(r){const r=n[o];if(!r)return[];const t=h(y);s=[];for(let a=t.findIndex((e=>e===o))+1;a<t.length&&n[t[a]].depth>r.depth;a+=1){const o=t[a];e&&f(n[o])||s.push(o)}}else s=k(n,o,e);if(t){const e=R(y);s=s.filter((o=>!1!==e[o]))}return s}),[y]),q=o.useCallback(((o,r)=>{const t=y.current.getRowNode(o);if(!t)throw new Error(`MUI X: No row with id #${o} found.`);if(t.parent!==v)throw new Error("MUI X: The row reordering do not support reordering of grouped rows yet.");if("leaf"!==t.type)throw new Error("MUI X: The row reordering do not support reordering of footer or grouping rows.");y.current.setState((t=>{const n=u(t,y.current.instanceId)[v],s=n.children,a=s.findIndex((e=>e===o));if(-1===a||a===r)return t;S.debug(`Moving row ${o} to index ${r}`);const i=[...s];return i.splice(r,0,i.splice(a,1)[0]),e({},t,{rows:e({},t.rows,{tree:e({},t.rows.tree,{[v]:e({},n,{children:i})})})})})),y.current.publishEvent("rowsSet")}),[y,S]),J={getRow:L,getRowId:N,getRowModels:Y,getRowsCount:O,getAllRowIds:V,setRows:$,updateRows:_,getRowNode:H,getRowIndexRelativeToVisibleRows:F,unstable_replaceRows:o.useCallback(((o,r)=>{if(M.signature===l.DataGrid&&r.length>1)throw new Error(["MUI X: You cannot replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.","You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature."].join("\n"));if(0===r.length)return;if(i(y)>1)throw new Error("`apiRef.current.unstable_replaceRows` is not compatible with tree data and row grouping");const t=e({},u(y)),s=e({},n(y)),a=e({},w(y)),c=t[v],d=[...c.children],p=new Set;for(let e=0;e<r.length;e+=1){const n=r[e],u=b(n,M.getRowId,"A row was provided without id when calling replaceRows()."),[i]=d.splice(o+e,1,u);p.has(i)||(delete s[i],delete a[i],delete t[i]);const w={id:u,depth:0,parent:v,type:"leaf",groupingKey:null};s[u]=n,a[u]=u,t[u]=w,p.add(u)}t[v]=e({},c,{children:d});const g=d.filter((e=>"leaf"===t[e]?.type));y.current.caches.rows.dataRowIdToModelLookup=s,y.current.caches.rows.dataRowIdToIdLookup=a,y.current.setState((o=>e({},o,{rows:e({},o.rows,{dataRowIdToModelLookup:s,dataRowIdToIdLookup:a,dataRowIds:g,tree:t})}))),y.current.publishEvent("rowsSet")}),[y,M.signature,M.getRowId])},Q={setRowIndex:q,setRowChildrenExpansion:z,getRowGroupChildren:K},W=o.useCallback((()=>{let o;S.info("Row grouping pre-processing have changed, regenerating the row tree"),o=y.current.caches.rows.rowsBeforePartialUpdates===M.rows?e({},y.current.caches.rows,{updates:{type:"full",rows:s(y)}}):I({rows:M.rows,getRowId:M.getRowId,loading:M.loading,rowCount:M.rowCount}),X({cache:o,throttle:!1})}),[S,y,M.rows,M.getRowId,M.loading,M.rowCount,X]),Z=o.useCallback((e=>{"rowTreeCreation"===e&&W()}),[W]),ee=o.useCallback((()=>{y.current.getActiveStrategy("rowTree")!==c(y)&&W()}),[y,W]);p(y,"activeStrategyProcessorChange",Z),p(y,"strategyAvailabilityChange",ee);const oe=o.useCallback((()=>{y.current.setState((o=>{const r=y.current.unstable_applyPipeProcessors("hydrateRows",{tree:u(o,y.current.instanceId),treeDepths:d(o,y.current.instanceId),dataRowIds:s(o,y.current.instanceId),dataRowIdToModelLookup:n(o,y.current.instanceId),dataRowIdToIdLookup:w(o,y.current.instanceId)});return e({},o,{rows:e({},o.rows,r,{totalTopLevelRowCount:P({tree:r.tree,rowCountProp:M.rowCount})})})})),y.current.publishEvent("rowsSet"),y.current.forceUpdate()}),[y,M.rowCount]);T(y,"hydrateRows",oe),r(y,J,"public"),r(y,Q,M.signature===l.DataGrid?"private":"public");const re=o.useRef(!0);o.useEffect((()=>{if(re.current)return void(re.current=!1);let o=!1;M.rowCount!==j.current&&(o=!0,j.current=M.rowCount);const r=y.current.caches.rows.rowsBeforePartialUpdates===M.rows,t=y.current.caches.rows.loadingPropBeforePartialUpdates===M.loading,n=y.current.caches.rows.rowCountPropBeforePartialUpdates===M.rowCount;r&&(t||(y.current.setState((o=>e({},o,{rows:e({},o.rows,{loading:M.loading})}))),y.current.caches.rows.loadingPropBeforePartialUpdates=M.loading,y.current.forceUpdate()),n||(y.current.setState((o=>e({},o,{rows:e({},o.rows,{totalRowCount:Math.max(M.rowCount||0,o.rows.totalRowCount),totalTopLevelRowCount:Math.max(M.rowCount||0,o.rows.totalTopLevelRowCount)})}))),y.current.caches.rows.rowCountPropBeforePartialUpdates=M.rowCount,y.current.forceUpdate()),!o)||(S.debug(`Updating all rows, new length ${M.rows.length}`),X({cache:I({rows:M.rows,getRowId:M.getRowId,loading:M.loading,rowCount:M.rowCount}),throttle:!1}))}),[M.rows,M.rowCount,M.getRowId,M.loading,S,X,y])};export{y as rowsStateInitializer,M as useGridRows};
