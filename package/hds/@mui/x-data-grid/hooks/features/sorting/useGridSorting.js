import r from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as e from"react";import{useGridApiEventHandler as t}from"../../utils/useGridApiEventHandler.js";import{useGridApiMethod as o}from"../../utils/useGridApiMethod.js";import{useGridLogger as s}from"../../utils/useGridLogger.js";import{gridColumnLookupSelector as l}from"../columns/gridColumnsSelector.js";import{gridSortModelSelector as n,gridSortedRowEntriesSelector as i,gridSortedRowIdsSelector as d}from"./gridSortingSelector.js";import{useFirstRender as u}from"../../utils/useFirstRender.js";import{getNextGridSortDirection as a,buildAggregatedSortingApplier as c,mergeStateWithSortModel as g,sanitizeSortModel as m}from"./gridSortingUtils.js";import{getTreeNodeDescendants as p,GRID_ROOT_GROUP_ID as S}from"../rows/gridRowsUtils.js";import{gridRowTreeSelector as f}from"../rows/gridRowsSelector.js";import b from"../../../../utils/useEnhancedEffect/useEnhancedEffect.js";import{useGridRegisterPipeProcessor as C}from"../../core/pipeProcessing/useGridRegisterPipeProcessor.js";import{useGridRegisterStrategyProcessor as M}from"../../core/strategyProcessing/useGridRegisterStrategyProcessor.js";import{GRID_DEFAULT_STRATEGY as y}from"../../core/strategyProcessing/useGridStrategyProcessing.js";const k=(e,t)=>{const o=t.sortModel??t.initialState?.sorting?.sortModel??[];return r({},e,{sorting:{sortModel:m(o,t.disableMultipleColumnsSorting),sortedRows:[]}})},h=(m,k)=>{const h=s(m,"useGridSorting");m.current.registerControlState({stateId:"sortModel",propModel:k.sortModel,propOnChange:k.onSortModelChange,stateSelector:n,changeEvent:"sortModelChange"});const w=e.useCallback(((r,e)=>{const t=n(m),o=t.findIndex((e=>e.field===r));let s=[...t];return o>-1?null==e?.sort?s.splice(o,1):s.splice(o,1,e):s=[...t,e],s}),[m]),R=e.useCallback(((e,t)=>{const o=n(m).find((r=>r.field===e.field));if(o){const s=void 0===t?a(e.sortingOrder??k.sortingOrder,o.sort):t;return void 0===s?void 0:r({},o,{sort:s})}return{field:e.field,sort:void 0===t?a(e.sortingOrder??k.sortingOrder):t}}),[m,k.sortingOrder]),j=e.useCallback(((r,e)=>{if(null==e||!1===e.sortable||k.disableColumnSorting)return r;return(e.sortingOrder||k.sortingOrder).some((r=>!!r))?[...r,"columnMenuSortItem"]:r}),[k.sortingOrder,k.disableColumnSorting]),v=e.useCallback((()=>{m.current.setState((e=>{if("server"===k.sortingMode)return h.debug("Skipping sorting rows as sortingMode = server"),r({},e,{sorting:r({},e.sorting,{sortedRows:p(f(m),S,!1)})});const t=n(e,m.current.instanceId),o=c(t,m),s=m.current.applyStrategyProcessor("sorting",{sortRowList:o});return r({},e,{sorting:r({},e.sorting,{sortedRows:s})})})),m.current.publishEvent("sortedRowsSet"),m.current.forceUpdate()}),[m,h,k.sortingMode]),I=e.useCallback((r=>{n(m)!==r&&(h.debug("Setting sort model"),m.current.setState(g(r,k.disableMultipleColumnsSorting)),m.current.forceUpdate(),m.current.applySorting())}),[m,h,k.disableMultipleColumnsSorting]),O=e.useCallback(((r,e,t)=>{const o=m.current.getColumn(r),s=R(o,e);let l;l=!t||k.disableMultipleColumnsSorting?null==s?.sort?[]:[s]:w(o.field,s),m.current.setSortModel(l)}),[m,w,R,k.disableMultipleColumnsSorting]),P=e.useCallback((()=>n(m)),[m]),E=e.useCallback((()=>i(m).map((r=>r.model))),[m]),G=e.useCallback((()=>d(m)),[m]),K=e.useCallback((r=>m.current.getSortedRowIds()[r]),[m]);o(m,{getSortModel:P,getSortedRows:E,getSortedRowIds:G,getRowIdFromRowIndex:K,setSortModel:I,sortColumn:O,applySorting:v},"public");const x=e.useCallback(((e,t)=>{const o=n(m);return!t.exportOnlyDirtyModels||null!=k.sortModel||null!=k.initialState?.sorting?.sortModel||o.length>0?r({},e,{sorting:{sortModel:o}}):e}),[m,k.sortModel,k.initialState?.sorting?.sortModel]),D=e.useCallback(((e,t)=>{const o=t.stateToRestore.sorting?.sortModel;return null==o?e:(m.current.setState(g(o,k.disableMultipleColumnsSorting)),r({},e,{callbacks:[...e.callbacks,m.current.applySorting]}))}),[m,k.disableMultipleColumnsSorting]),L=e.useCallback((r=>{const e=f(m),t=e[S],o=r.sortRowList?r.sortRowList(t.children.map((r=>e[r]))):[...t.children];return null!=t.footerId&&o.push(t.footerId),o}),[m]);C(m,"exportState",x),C(m,"restoreState",D),M(m,y,"sorting",L);const U=e.useCallback((({field:r,colDef:e},t)=>{if(!e.sortable||k.disableColumnSorting)return;const o=t.shiftKey||t.metaKey||t.ctrlKey;O(r,void 0,o)}),[O,k.disableColumnSorting]),H=e.useCallback((({field:r,colDef:e},t)=>{e.sortable&&!k.disableColumnSorting&&("Enter"!==t.key||t.ctrlKey||t.metaKey||O(r,void 0,t.shiftKey))}),[O,k.disableColumnSorting]),A=e.useCallback((()=>{const r=n(m),e=l(m);if(r.length>0){const t=r.filter((r=>e[r.field]));t.length<r.length&&m.current.setSortModel(t)}}),[m]),F=e.useCallback((r=>{"sorting"===r&&m.current.applySorting()}),[m]);C(m,"columnMenu",j),t(m,"columnHeaderClick",U),t(m,"columnHeaderKeyDown",H),t(m,"rowsSet",m.current.applySorting),t(m,"columnsChange",A),t(m,"activeStrategyProcessorChange",F),u((()=>{m.current.applySorting()})),b((()=>{void 0!==k.sortModel&&m.current.setSortModel(k.sortModel)}),[m,k.sortModel])};export{k as sortingStateInitializer,h as useGridSorting};
