import e from"../../../../../@babel/runtime/helpers/esm/extends.js";import*as t from"react";import{useGridApiMethod as n}from"../../utils/useGridApiMethod.js";import{useGridLogger as l}from"../../utils/useGridLogger.js";import{gridColumnVisibilityModelSelector as o,gridColumnLookupSelector as i,gridColumnDefinitionsSelector as s,gridVisibleColumnDefinitionsSelector as r,gridColumnPositionsSelector as u,gridColumnFieldsSelector as c,gridColumnsStateSelector as m}from"./gridColumnsSelector.js";import{GridSignature as a,useGridApiEventHandler as d}from"../../utils/useGridApiEventHandler.js";import{EMPTY_PINNED_COLUMN_FIELDS as p}from"./gridColumnsInterfaces.js";import{createColumnsState as C,hydrateColumnsWidth as b,COLUMNS_DIMENSION_PROPERTIES as f}from"./gridColumnsUtils.js";import{jsx as g}from"react/jsx-runtime";import{GridPreferencePanelsValue as h}from"../preferencesPanel/gridPreferencePanelsValue.js";import{useGridRegisterPipeProcessor as y}from"../../core/pipeProcessing/useGridRegisterPipeProcessor.js";import{useGridRegisterPipeApplier as k}from"../../core/pipeProcessing/useGridRegisterPipeApplier.js";const M=(t,n,l)=>{const o=C({apiRef:l,columnsToUpsert:n.columns,initialState:n.initialState?.columns,columnVisibilityModel:n.columnVisibilityModel??n.initialState?.columns?.columnVisibilityModel??{},keepOnlyColumnsToUpsert:!0});return e({},t,{columns:o,pinnedColumns:t.pinnedColumns??p})};function V(p,M){const V=l(p,"useGridColumns"),S=t.useRef(M.columns);p.current.registerControlState({stateId:"visibleColumns",propModel:M.columnVisibilityModel,propOnChange:M.onColumnVisibilityModelChange,stateSelector:o,changeEvent:"columnVisibilityModelChange"});const v=t.useCallback((e=>{V.debug("Updating columns state."),p.current.setState(R(e)),p.current.publishEvent("columnsChange",e.orderedFields),p.current.updateRenderContext?.(),p.current.forceUpdate()}),[V,p]),x=t.useCallback((e=>i(p)[e]),[p]),U=t.useCallback((()=>s(p)),[p]),P=t.useCallback((()=>r(p)),[p]),T=t.useCallback(((e,t=!0)=>(t?r(p):s(p)).findIndex((t=>t.field===e))),[p]),j=t.useCallback((e=>{const t=T(e);return u(p)[t]}),[p,T]),I=t.useCallback((t=>{o(p)!==t&&(p.current.setState((n=>e({},n,{columns:C({apiRef:p,columnsToUpsert:[],initialState:void 0,columnVisibilityModel:t,keepOnlyColumnsToUpsert:!1})}))),p.current.updateRenderContext?.(),p.current.forceUpdate())}),[p]),E=t.useCallback((e=>{const t=C({apiRef:p,columnsToUpsert:e,initialState:void 0,keepOnlyColumnsToUpsert:!1});v(t)}),[p,v]),O=t.useCallback(((t,n)=>{const l=o(p);if(n!==(l[t]??!0)){const o=e({},l,{[t]:n});p.current.setColumnVisibilityModel(o)}}),[p]),G=t.useCallback((e=>c(p).findIndex((t=>t===e))),[p]),w=t.useCallback(((t,n)=>{const l=c(p),o=G(t);if(o===n)return;V.debug(`Moving column ${t} to index ${n}`);const i=[...l],s=i.splice(o,1)[0];i.splice(n,0,s),v(e({},m(p.current.state),{orderedFields:i}));const r={column:p.current.getColumn(t),targetIndex:p.current.getColumnIndexRelativeToVisibleColumns(t),oldIndex:o};p.current.publishEvent("columnIndexChange",r)}),[p,V,v,G]),D=t.useCallback(((t,n)=>{V.debug(`Updating column ${t} width to ${n}`);const l=m(p.current.state),o=l.lookup[t],i=e({},o,{width:n,hasBeenResized:!0});v(b(e({},l,{lookup:e({},l.lookup,{[t]:i})}),p.current.getRootDimensions())),p.current.publishEvent("columnWidthChange",{element:p.current.getColumnHeaderElement(t),colDef:i,width:n})}),[p,V,v]),$={setColumnIndex:w};n(p,{getColumn:x,getAllColumns:U,getColumnIndex:T,getColumnPosition:j,getVisibleColumns:P,getColumnIndexRelativeToVisibleColumns:G,updateColumns:E,setColumnVisibilityModel:I,setColumnVisibility:O,setColumnWidth:D},"public"),n(p,$,M.signature===a.DataGrid?"private":"public");const A=t.useCallback(((t,n)=>{const l={},i=o(p);(!n.exportOnlyDirtyModels||null!=M.columnVisibilityModel||Object.keys(M.initialState?.columns?.columnVisibilityModel??{}).length>0||Object.keys(i).length>0)&&(l.columnVisibilityModel=i),l.orderedFields=c(p);const r=s(p),u={};return r.forEach((e=>{if(e.hasBeenResized){const t={};f.forEach((n=>{let l=e[n];l===1/0&&(l=-1),t[n]=l})),u[e.field]=t}})),Object.keys(u).length>0&&(l.dimensions=u),e({},t,{columns:l})}),[p,M.columnVisibilityModel,M.initialState?.columns]),F=t.useCallback(((e,t)=>{const n=t.stateToRestore.columns?.columnVisibilityModel,l=t.stateToRestore.columns;if(null==n&&null==l)return e;const o=C({apiRef:p,columnsToUpsert:[],initialState:l,columnVisibilityModel:n,keepOnlyColumnsToUpsert:!1});return p.current.setState(R(o)),null!=l&&p.current.publishEvent("columnsChange",o.orderedFields),e}),[p]),z=t.useCallback(((t,n)=>{if(n===h.columns){const t=M.slots.columnsPanel;return g(t,e({},M.slotProps?.columnsPanel))}return t}),[M.slots.columnsPanel,M.slotProps?.columnsPanel]),B=t.useCallback((e=>M.disableColumnSelector?e:[...e,"columnMenuColumnsItem"]),[M.disableColumnSelector]);y(p,"columnMenu",B),y(p,"exportState",A),y(p,"restoreState",F),y(p,"preferencePanel",z);const H=t.useRef(null);d(p,"viewportInnerSizeChange",(e=>{H.current!==e.width&&(H.current=e.width,v(b(m(p.current.state),p.current.getRootDimensions())))}));const W=t.useCallback((()=>{V.info("Columns pipe processing have changed, regenerating the columns");const e=C({apiRef:p,columnsToUpsert:[],initialState:void 0,keepOnlyColumnsToUpsert:!1});v(e)}),[p,V,v]);k(p,"hydrateColumns",W);const L=t.useRef(!0);t.useEffect((()=>{if(L.current)return void(L.current=!1);if(V.info(`GridColumns have changed, new length ${M.columns.length}`),S.current===M.columns)return;const e=C({apiRef:p,initialState:void 0,columnsToUpsert:M.columns,keepOnlyColumnsToUpsert:!0});S.current=M.columns,v(e)}),[V,p,v,M.columns]),t.useEffect((()=>{void 0!==M.columnVisibilityModel&&p.current.setColumnVisibilityModel(M.columnVisibilityModel)}),[p,V,M.columnVisibilityModel])}function R(t){return n=>e({},n,{columns:t})}export{M as columnsStateInitializer,V as useGridColumns};
