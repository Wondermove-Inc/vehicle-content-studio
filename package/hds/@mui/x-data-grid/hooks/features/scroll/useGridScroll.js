import*as o from"react";import{useGridLogger as e}from"../../utils/useGridLogger.js";import{gridVisibleColumnDefinitionsSelector as t,gridColumnPositionsSelector as r}from"../columns/gridColumnsSelector.js";import{useGridSelector as l}from"../../utils/useGridSelector.js";import{gridPageSelector as i,gridPageSizeSelector as n}from"../pagination/gridPaginationSelector.js";import{gridRowCountSelector as s}from"../rows/gridRowsSelector.js";import{gridRowsMetaSelector as c}from"../rows/gridRowsMetaSelector.js";import{useGridApiMethod as p}from"../../utils/useGridApiMethod.js";import{gridExpandedSortedRowEntriesSelector as d}from"../filter/gridFilterSelector.js";import f from"../../../../material/styles/useTheme.js";import{gridDimensionsSelector as u}from"../dimensions/gridDimensionsSelectors.js";function a(o){const{clientHeight:e,scrollTop:t,offsetHeight:r,offsetTop:l}=o,i=l+r;return r>e?l:i-e>t?i-e:l<t?l:void 0}const g=(g,m)=>{const S=f(),w=e(g,"useGridScroll"),I=g.current.columnHeadersContainerRef,h=g.current.virtualScrollerRef,x=l(g,d),v=o.useCallback((o=>{const e=u(g.current.state),l=s(g),p=t(g);if(!(null==o.rowIndex)&&0===l||0===p.length)return!1;w.debug(`Scrolling to cell at row ${o.rowIndex}, col: ${o.colIndex} `);let d={};if(void 0!==o.colIndex){const t=r(g);let l;if(void 0!==o.rowIndex){const e=x[o.rowIndex]?.id,t=g.current.unstable_getCellColSpanInfo(e,o.colIndex);t&&!t.spannedByColSpan&&(l=t.cellProps.width)}void 0===l&&(l=p[o.colIndex].computedWidth),d.left=a({clientHeight:e.viewportInnerSize.width,scrollTop:Math.abs(h.current.scrollLeft),offsetHeight:l,offsetTop:t[o.colIndex]})}if(void 0!==o.rowIndex){const t=c(g.current.state),r=i(g),l=n(g),s=m.pagination?o.rowIndex-r*l:o.rowIndex,p=t.positions[s+1]?t.positions[s+1]-t.positions[s]:t.currentPageTotalHeight-t.positions[s];d.top=a({clientHeight:e.viewportInnerSize.height,scrollTop:h.current.scrollTop,offsetHeight:p,offsetTop:t.positions[s]})}return d=g.current.unstable_applyPipeProcessors("scrollToIndexes",d,o),(void 0!==typeof d.left||void 0!==typeof d.top)&&(g.current.scroll(d),!0)}),[w,g,h,m.pagination,x]),T=o.useCallback((o=>{if(h.current&&void 0!==o.left&&I.current){const e="rtl"===S.direction?-1:1;I.current.scrollLeft=o.left,h.current.scrollLeft=e*o.left,w.debug(`Scrolling left: ${o.left}`)}h.current&&void 0!==o.top&&(h.current.scrollTop=o.top,w.debug(`Scrolling top: ${o.top}`)),w.debug("Scrolling, updating container, and viewport")}),[h,S.direction,I,w]),b=o.useCallback((()=>h?.current?{top:h.current.scrollTop,left:h.current.scrollLeft}:{top:0,left:0}),[h]);p(g,{scroll:T,scrollToIndexes:v,getScrollPosition:b},"public")};export{g as useGridScroll};
