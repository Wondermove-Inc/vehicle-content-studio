import{buildWarning as e}from"../../../../utils/warning.js";import{GRID_CHECKBOX_SELECTION_COL_DEF as t}from"../../../../colDef/gridCheckboxSelectionColDef.js";function r(e,t){if("string"==typeof e){if(t.shouldAppendQuotes||t.escapeFormulas){const r=e.replace(/"/g,'""');return[t.delimiter,"\n","\r",'"'].some((t=>e.includes(t)))?`"${r}"`:t.escapeFormulas&&["=","+","-","@","\t","\r"].includes(r[0])?`'${r}`:r}return e}return e}const o=(e,t)=>{const{csvOptions:o,ignoreValueFormatter:i}=t;let n;if(i){const t=e.colDef.type;n="number"===t?String(e.value):"date"===t||"dateTime"===t?e.value?.toISOString():"function"==typeof e.value?.toString?e.value.toString():e.value}else n=e.formattedValue;return r(n,o)},i=e(["MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.","You can provide a `valueFormatter` with a string representation to be used."]);class n{constructor(e){this.options=void 0,this.rowString="",this.isEmpty=!0,this.options=e}addValue(e){this.isEmpty||(this.rowString+=this.options.csvOptions.delimiter),null==e?this.rowString+="":"function"==typeof this.options.sanitizeCellValue?this.rowString+=this.options.sanitizeCellValue(e,this.options.csvOptions):this.rowString+=e,this.isEmpty=!1}getRowString(){return this.rowString}}function s(e){const{columns:s,rowIds:l,csvOptions:a,ignoreValueFormatter:u,apiRef:c}=e,d=l.reduce(((e,t)=>`${e}${(({id:e,columns:t,getCellParams:r,csvOptions:s,ignoreValueFormatter:l})=>{const a=new n({csvOptions:s});return t.forEach((t=>{const n=r(e,t.field);"production"!==process.env.NODE_ENV&&"[object Object]"===String(n.formattedValue)&&i(),a.addValue(o(n,{ignoreValueFormatter:l,csvOptions:s}))})),a.getRowString()})({id:t,columns:s,getCellParams:c.current.getCellParams,ignoreValueFormatter:u,csvOptions:a})}\r\n`),"").trim();if(!a.includeHeaders)return d;const p=s.filter((e=>e.field!==t.field)),m=[];if(a.includeColumnGroupsHeaders){const e=c.current.getAllGroupDetails();let t=0;const o=p.reduce(((e,r)=>{const o=c.current.getColumnGroupPath(r.field);return e[r.field]=o,t=Math.max(t,o.length),e}),{});for(let i=0;i<t;i+=1){const t=new n({csvOptions:a,sanitizeCellValue:r});m.push(t),p.forEach((r=>{const n=(o[r.field]||[])[i],s=e[n];t.addValue(s?s.headerName||s.groupId:"")}))}}const g=new n({csvOptions:a,sanitizeCellValue:r});p.forEach((e=>{g.addValue(e.headerName||e.field)})),m.push(g);return`${`${m.map((e=>e.getRowString())).join("\r\n")}\r\n`}${d}`.trim()}export{s as buildCSV,o as serializeCellValue};
