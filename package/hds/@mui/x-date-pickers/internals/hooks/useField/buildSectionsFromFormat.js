import e from"../../../../../@babel/runtime/helpers/esm/extends.js";import{getDateSectionConfigFromFormatToken as t,doesSectionFormatHaveLeadingZeros as r,applyLocalizedDigits as n,cleanLeadingZeros as a,removeLocalizedDigits as o}from"./useField.utils.js";const l=(e,t,r,n,a)=>{switch(n.type){case"year":return r.fieldYearPlaceholder({digitAmount:e.formatByString(e.date(void 0,t),a).length,format:a});case"month":return r.fieldMonthPlaceholder({contentType:n.contentType,format:a});case"day":return r.fieldDayPlaceholder({format:a});case"weekDay":return r.fieldWeekDayPlaceholder({contentType:n.contentType,format:a});case"hours":return r.fieldHoursPlaceholder({format:a});case"minutes":return r.fieldMinutesPlaceholder({format:a});case"seconds":return r.fieldSecondsPlaceholder({format:a});case"meridiem":return r.fieldMeridiemPlaceholder({format:a});default:return a}},s=({utils:s,timezone:i,date:d,shouldRespectLeadingZeros:c,localeText:p,localizedDigits:m,now:u,token:h,startSeparator:f})=>{if(""===h)throw new Error("MUI X: Should not call `commitToken` with an empty token");const g=t(s,h),x=r(s,i,g.contentType,g.type,h),y=c?x:"digit"===g.contentType,S=null!=d&&s.isValid(d);let w=S?s.formatByString(d,h):"",T=null;if(y)if(x)T=""===w?s.formatByString(u,h).length:w.length;else{if(null==g.maxLength)throw new Error(`MUI X: The token ${h} should have a 'maxDigitNumber' property on it's adapter`);T=g.maxLength,S&&(w=n(a(o(w,m),T),m))}return e({},g,{format:h,maxLength:T,value:w,placeholder:l(s,i,p,g,h),hasLeadingZerosInFormat:x,hasLeadingZerosInInput:y,startSeparator:f,endSeparator:"",modified:!1})},i=t=>{let r=(({utils:e,format:t})=>{let r=10,n=t,a=e.expandFormat(t);for(;a!==n;)if(n=a,a=e.expandFormat(n),r-=1,r<0)throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");return a})(t);t.isRtl&&t.enableAccessibleFieldDOMStructure&&(r=r.split(" ").reverse().join(" "));const n=(({utils:e,expandedFormat:t})=>{const r=[],{start:n,end:a}=e.escapedCharacters,o=new RegExp(`(\\${n}[^\\${a}]*\\${a})+`,"g");let l=null;for(;l=o.exec(t);)r.push({start:l.index,end:o.lastIndex-1});return r})(e({},t,{expandedFormat:r})),a=(t=>{const{utils:r,expandedFormat:n,escapedParts:a}=t,o=r.date(void 0),l=[];let i="";const d=Object.keys(r.formatTokenMap).sort(((e,t)=>t.length-e.length)),c=/^([a-zA-Z]+)/,p=new RegExp(`^(${d.join("|")})*$`),m=new RegExp(`^(${d.join("|")})`),u=e=>a.find((t=>t.start<=e&&t.end>=e));let h=0;for(;h<n.length;){const r=u(h),a=null!=r,d=c.exec(n.slice(h))?.[1];if(!a&&null!=d&&p.test(d)){let r=d;for(;r.length>0;){const n=m.exec(r)[1];r=r.slice(n.length),l.push(s(e({},t,{now:o,token:n,startSeparator:i}))),i=""}h+=d.length}else{const e=n[h];a&&r?.start===h||r?.end===h||(0===l.length?i+=e:l[l.length-1].endSeparator+=e),h+=1}}return 0===l.length&&i.length>0&&l.push({type:"empty",contentType:"letter",maxLength:null,format:"",value:"",placeholder:"",hasLeadingZerosInFormat:!1,hasLeadingZerosInInput:!1,startSeparator:i,endSeparator:"",modified:!1}),l})(e({},t,{expandedFormat:r,escapedParts:n}));return(({isRtl:e,formatDensity:t,sections:r})=>r.map((r=>{const n=r=>{let n=r;return e&&null!==n&&n.includes(" ")&&(n=`⁩${n}⁦`),"spacious"===t&&["/",".","-"].includes(n)&&(n=` ${n} `),n};return r.startSeparator=n(r.startSeparator),r.endSeparator=n(r.endSeparator),r})))(e({},t,{sections:a}))};export{i as buildSectionsFromFormat};
