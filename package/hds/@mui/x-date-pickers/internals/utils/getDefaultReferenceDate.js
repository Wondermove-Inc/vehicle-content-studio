import{createIsAfterIgnoreDatePart as e}from"./time-utils.js";import{getTodayDate as t,mergeDateAndTime as i}from"./date-utils.js";const a={year:1,month:2,day:3,hours:4,minutes:5,seconds:6,milliseconds:7},n=e=>Math.max(...e.map((e=>a[e.type]??1))),m=(e,t,i)=>{if(t===a.year)return e.startOfYear(i);if(t===a.month)return e.startOfMonth(i);if(t===a.day)return e.startOfDay(i);let n=i;return t<a.minutes&&(n=e.setMinutes(n,0)),t<a.seconds&&(n=e.setSeconds(n,0)),t<a.milliseconds&&(n=e.setMilliseconds(n,0)),n},r=({props:a,utils:n,granularity:r,timezone:s,getTodayDate:o})=>{let l=o?o():m(n,r,t(n,s));null!=a.minDate&&n.isAfterDay(a.minDate,l)&&(l=m(n,r,a.minDate)),null!=a.maxDate&&n.isBeforeDay(a.maxDate,l)&&(l=m(n,r,a.maxDate));const u=e(a.disableIgnoringDatePartForTimeValidation??!1,n);return null!=a.minTime&&u(a.minTime,l)&&(l=m(n,r,a.disableIgnoringDatePartForTimeValidation?a.minTime:i(n,l,a.minTime))),null!=a.maxTime&&u(l,a.maxTime)&&(l=m(n,r,a.disableIgnoringDatePartForTimeValidation?a.maxTime:i(n,l,a.maxTime))),l};export{a as SECTION_TYPE_GRANULARITY,r as getDefaultReferenceDate,n as getSectionTypeGranularity};
