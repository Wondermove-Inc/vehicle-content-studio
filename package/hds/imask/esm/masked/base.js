import t from"../core/change-details.js";import e from"../core/continuous-tail-details.js";import{isString as i,DIRECTION as s,objectIncludes as a,forceDirection as r}from"../core/utils.js";import h from"../core/holder.js";class n{constructor(t){this._value="",this._update({...n.DEFAULTS,...t}),this._initialized=!0}updateOptions(t){this.optionsIsChanged(t)&&this.withValueRefresh(this._update.bind(this,t))}_update(t){Object.assign(this,t)}get state(){return{_value:this.value,_rawInputValue:this.rawInputValue}}set state(t){this._value=t._value}reset(){this._value=""}get value(){return this._value}set value(t){this.resolve(t,{input:!0})}resolve(t,e){void 0===e&&(e={input:!0}),this.reset(),this.append(t,e,""),this.doCommit()}get unmaskedValue(){return this.value}set unmaskedValue(t){this.resolve(t,{})}get typedValue(){return this.parse?this.parse(this.value,this):this.unmaskedValue}set typedValue(t){this.format?this.value=this.format(t,this):this.unmaskedValue=String(t)}get rawInputValue(){return this.extractInput(0,this.displayValue.length,{raw:!0})}set rawInputValue(t){this.resolve(t,{raw:!0})}get displayValue(){return this.value}get isComplete(){return!0}get isFilled(){return this.isComplete}nearestInputPos(t,e){return t}totalInputPositions(t,e){return void 0===t&&(t=0),void 0===e&&(e=this.displayValue.length),Math.min(this.displayValue.length,e-t)}extractInput(t,e,i){return void 0===t&&(t=0),void 0===e&&(e=this.displayValue.length),this.displayValue.slice(t,e)}extractTail(t,i){return void 0===t&&(t=0),void 0===i&&(i=this.displayValue.length),new e(this.extractInput(t,i),t)}appendTail(t){return i(t)&&(t=new e(String(t))),t.appendTo(this)}_appendCharRaw(e,i){return e?(this._value+=e,new t({inserted:e,rawInserted:e})):new t}_appendChar(e,i,s){void 0===i&&(i={});const a=this.state;let r;if([e,r]=this.doPrepareChar(e,i),e&&(r=r.aggregate(this._appendCharRaw(e,i)),!r.rawInserted&&"pad"===this.autofix)){const t=this.state;this.state=a;let s=this.pad(i);const h=this._appendCharRaw(e,i);s=s.aggregate(h),h.rawInserted||s.equals(r)?r=s:this.state=t}if(r.inserted){let e,h=!1!==this.doValidate(i);if(h&&null!=s){const t=this.state;if(!0===this.overwrite){e=s.state;for(let t=0;t<r.rawInserted.length;++t)s.unshift(this.displayValue.length-r.tailShift)}let i=this.appendTail(s);if(h=i.rawInserted.length===s.toString().length,!(h&&i.inserted||"shift"!==this.overwrite)){this.state=t,e=s.state;for(let t=0;t<r.rawInserted.length;++t)s.shift();i=this.appendTail(s),h=i.rawInserted.length===s.toString().length}h&&i.inserted&&(this.state=t)}h||(r=new t,this.state=a,s&&e&&(s.state=e))}return r}_appendPlaceholder(){return new t}_appendEager(){return new t}append(t,s,a){if(!i(t))throw new Error("value should be string");const r=i(a)?new e(String(a)):a;let h;null!=s&&s.tail&&(s._beforeTailState=this.state),[t,h]=this.doPrepare(t,s);for(let e=0;e<t.length;++e){const i=this._appendChar(t[e],s,r);if(!i.rawInserted&&!this.doSkipInvalid(t[e],s,r))break;h.aggregate(i)}return(!0===this.eager||"append"===this.eager)&&null!=s&&s.input&&t&&h.aggregate(this._appendEager()),null!=r&&(h.tailShift+=this.appendTail(r).tailShift),h}remove(e,i){return void 0===e&&(e=0),void 0===i&&(i=this.displayValue.length),this._value=this.displayValue.slice(0,e)+this.displayValue.slice(i),new t}withValueRefresh(t){if(this._refreshing||!this._initialized)return t();this._refreshing=!0;const e=this.rawInputValue,i=this.value,s=t();return this.rawInputValue=e,this.value&&this.value!==i&&0===i.indexOf(this.value)&&(this.append(i.slice(this.displayValue.length),{},""),this.doCommit()),delete this._refreshing,s}runIsolated(t){if(this._isolated||!this._initialized)return t(this);this._isolated=!0;const e=this.state,i=t(this);return this.state=e,delete this._isolated,i}doSkipInvalid(t,e,i){return Boolean(this.skipInvalid)}doPrepare(e,i){return void 0===i&&(i={}),t.normalize(this.prepare?this.prepare(e,this,i):e)}doPrepareChar(e,i){return void 0===i&&(i={}),t.normalize(this.prepareChar?this.prepareChar(e,this,i):e)}doValidate(t){return(!this.validate||this.validate(this.value,this,t))&&(!this.parent||this.parent.doValidate(t))}doCommit(){this.commit&&this.commit(this.value,this)}splice(e,i,a,h,n){void 0===a&&(a=""),void 0===h&&(h=s.NONE),void 0===n&&(n={input:!0});const l=e+i,u=this.extractTail(l),d=!0===this.eager||"remove"===this.eager;let p;d&&(h=r(h),p=this.extractInput(0,l,{raw:!0}));let o=e;const g=new t;if(h!==s.NONE&&(o=this.nearestInputPos(e,i>1&&0!==e&&!d?s.NONE:h),g.tailShift=o-e),g.aggregate(this.remove(o)),d&&h!==s.NONE&&p===this.rawInputValue)if(h===s.FORCE_LEFT){let e;for(;p===this.rawInputValue&&(e=this.displayValue.length);)g.aggregate(new t({tailShift:-1})).aggregate(this.remove(e-1))}else h===s.FORCE_RIGHT&&u.unshift();return g.aggregate(this.append(a,n,u))}maskEquals(t){return this.mask===t}optionsIsChanged(t){return!a(this,t)}typedValueEquals(t){const e=this.typedValue;return t===e||n.EMPTY_VALUES.includes(t)&&n.EMPTY_VALUES.includes(e)||!!this.format&&this.format(t,this)===this.format(this.typedValue,this)}pad(e){return new t}}n.DEFAULTS={skipInvalid:!0},n.EMPTY_VALUES=[void 0,null,""],h.Masked=n;export{n as default};
