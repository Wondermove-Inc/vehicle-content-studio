import t from"./pattern.js";import e from"./range.js";import s from"../core/holder.js";import{isString as a}from"../core/utils.js";import"../core/change-details.js";import"./base.js";import"./factory.js";import"./pattern/input-definition.js";import"./regexp.js";class r extends t{static extractPatternOptions(t){const{mask:e,pattern:s,...r}=t;return{...r,mask:a(e)?e:s}}constructor(t){super(r.extractPatternOptions({...r.DEFAULTS,...t}))}updateOptions(t){super.updateOptions(t)}_update(t){const{mask:e,pattern:s,blocks:o,...i}={...r.DEFAULTS,...t},n=Object.assign({},r.GET_DEFAULT_BLOCKS());t.min&&(n.Y.from=t.min.getFullYear()),t.max&&(n.Y.to=t.max.getFullYear()),t.min&&t.max&&n.Y.from===n.Y.to&&(n.m.from=t.min.getMonth()+1,n.m.to=t.max.getMonth()+1,n.m.from===n.m.to&&(n.d.from=t.min.getDate(),n.d.to=t.max.getDate())),Object.assign(n,this.blocks,o),super._update({...i,mask:a(e)?e:s,blocks:n})}doValidate(t){const e=this.date;return super.doValidate(t)&&(!this.isComplete||this.isDateExist(this.value)&&null!=e&&(null==this.min||this.min<=e)&&(null==this.max||e<=this.max))}isDateExist(t){return this.format(this.parse(t,this),this).indexOf(t)>=0}get date(){return this.typedValue}set date(t){this.typedValue=t}get typedValue(){return this.isComplete?super.typedValue:null}set typedValue(t){super.typedValue=t}maskEquals(t){return t===Date||super.maskEquals(t)}optionsIsChanged(t){return super.optionsIsChanged(r.extractPatternOptions(t))}}r.GET_DEFAULT_BLOCKS=()=>({d:{mask:e,from:1,to:31,maxLength:2},m:{mask:e,from:1,to:12,maxLength:2},Y:{mask:e,from:1900,to:9999}}),r.DEFAULTS={...t.DEFAULTS,mask:Date,pattern:"d{.}`m{.}`Y",format:(t,e)=>{if(!t)return"";return[String(t.getDate()).padStart(2,"0"),String(t.getMonth()+1).padStart(2,"0"),t.getFullYear()].join(".")},parse:(t,e)=>{const[s,a,r]=t.split(".").map(Number);return new Date(r,a-1,s)}},s.MaskedDate=r;export{r as default};
