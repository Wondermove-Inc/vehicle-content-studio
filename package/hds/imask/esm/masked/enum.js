import e from"./pattern.js";import t from"../core/holder.js";import s from"../core/change-details.js";import{DIRECTION as a}from"../core/utils.js";import i from"../core/continuous-tail-details.js";import"./base.js";import"./factory.js";import"./pattern/input-definition.js";import"./regexp.js";class n extends e{constructor(e){super({...n.DEFAULTS,...e})}updateOptions(e){super.updateOptions(e)}_update(e){const{enum:t,...s}=e;if(t){const e=t.map((e=>e.length)),a=Math.min(...e),i=Math.max(...e)-a;s.mask="*".repeat(a),i&&(s.mask+="["+"*".repeat(i)+"]"),this.enum=t}super._update(s)}_appendCharRaw(e,t){void 0===t&&(t={});const i=Math.min(this.nearestInputPos(0,a.FORCE_RIGHT),this.value.length),n=this.enum.filter((t=>this.matchValue(t,this.unmaskedValue+e,i)));if(n.length){1===n.length&&this._forEachBlocksInRange(0,this.value.length,((e,s)=>{const a=n[0][s];s>=this.value.length||a===e.value||(e.reset(),e._appendChar(a,t))}));const e=super._appendCharRaw(n[0][this.value.length],t);return 1===n.length&&n[0].slice(this.unmaskedValue.length).split("").forEach((t=>e.aggregate(super._appendCharRaw(t)))),e}return new s({skip:!this.isComplete})}extractTail(e,t){return void 0===e&&(e=0),void 0===t&&(t=this.displayValue.length),new i("",e)}remove(e,t){if(void 0===e&&(e=0),void 0===t&&(t=this.displayValue.length),e===t)return new s;const i=Math.min(super.nearestInputPos(0,a.FORCE_RIGHT),this.value.length);let n;for(n=e;n>=0;--n){if(this.enum.filter((e=>this.matchValue(e,this.value.slice(i,n),i))).length>1)break}const r=super.remove(n,t);return r.tailShift+=n-e,r}get isComplete(){return this.enum.indexOf(this.value)>=0}}n.DEFAULTS={...e.DEFAULTS,matchValue:(e,t,s)=>e.indexOf(t,s)===s},t.MaskedEnum=n;export{n as default};
