import{constructFrom as t}from"./constructFrom.js";import{getDefaultOptions as e}from"./getDefaultOptions.js";import{toDate as r}from"./toDate.js";import{longFormatters as o}from"./_lib/format/longFormatters.js";import{isProtectedWeekYearToken as n,warnOrThrowProtectedError as a,isProtectedDayOfYearToken as s}from"./_lib/protectedTokens.js";import{parsers as i}from"./parse/_lib/parsers.js";import{DateToSystemTimezoneSetter as l}from"./parse/_lib/Setter.js";import{enUS as f}from"./locale/en-US.js";const c=/[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,m=/P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,p=/^'([^]*?)'?$/,u=/''/g,k=/\S/,h=/[a-zA-Z]/;function g(g,d,w,N){const y=e(),b=N?.locale??y.locale??f,j=N?.firstWeekContainsDate??N?.locale?.options?.firstWeekContainsDate??y.firstWeekContainsDate??y.locale?.options?.firstWeekContainsDate??1,O=N?.weekStartsOn??N?.locale?.options?.weekStartsOn??y.weekStartsOn??y.locale?.options?.weekStartsOn??0;if(""===d)return""===g?r(w):t(w,NaN);const T={firstWeekContainsDate:j,weekStartsOn:O,locale:b},D=[new l],S=d.match(m).map((t=>{const e=t[0];if(e in o){return(0,o[e])(t,b.formatLong)}return t})).join("").match(c),A=[];for(let e of S){!N?.useAdditionalWeekYearTokens&&n(e)&&a(e,d,g),!N?.useAdditionalDayOfYearTokens&&s(e)&&a(e,d,g);const r=e[0],o=i[r];if(o){const{incompatibleTokens:n}=o;if(Array.isArray(n)){const t=A.find((t=>n.includes(t.token)||t.token===r));if(t)throw new RangeError(`The format string mustn't contain \`${t.fullToken}\` and \`${e}\` at the same time`)}else if("*"===o.incompatibleTokens&&A.length>0)throw new RangeError(`The format string mustn't contain \`${e}\` and any other token at the same time`);A.push({token:r,fullToken:e});const a=o.run(g,e,b.match,T);if(!a)return t(w,NaN);D.push(a.setter),g=a.rest}else{if(r.match(h))throw new RangeError("Format string contains an unescaped latin alphabet character `"+r+"`");if("''"===e?e="'":"'"===r&&(e=e.match(p)[1].replace(u,"'")),0!==g.indexOf(e))return t(w,NaN);g=g.slice(e.length)}}if(g.length>0&&k.test(g))return t(w,NaN);const W=D.map((t=>t.priority)).sort(((t,e)=>e-t)).filter(((t,e,r)=>r.indexOf(t)===e)).map((t=>D.filter((e=>e.priority===t)).sort(((t,e)=>e.subPriority-t.subPriority)))).map((t=>t[0]));let $=r(w);if(isNaN($.getTime()))return t(w,NaN);const C={};for(const e of W){if(!e.validate($,T))return t(w,NaN);const r=e.set($,C,T);Array.isArray(r)?($=r[0],Object.assign(C,r[1])):$=r}return t(w,$)}export{g as default,o as longFormatters,g as parse,i as parsers};
